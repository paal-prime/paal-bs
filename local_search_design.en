=============================
LOCAL SEARCH FRAMEWORK DESIGN
=============================
Author: Grzegorz Prusak

Table of contents:
1. Main function
2. Concepts
3. Features for implementing a Walker

================
1. MAIN FUNCTION
================

template<typename Walker, typename StepCtrl, typename ProgressCtrl, typename Random, typename Logger>
	void search(Walker &walker, StepCtrl &step_ctrl, ProgressCtrl &progress_ctrl, Random &random, Logger &logger)
{
	while(1)
	{
		double current_fitness = walker.current_fitness();
		logger.log(current_fitness);
		double progress = progress_ctrl.progress(walker.best_fitness());
		if(progress>=1) break;
		walker.prepare_step(progress,random);
		if(step_ctrl.step_decision(walker.next_fitness()-current_fitness,progress,random))
			walker.make_step();
	}
}


===========
2. CONCEPTS
===========

concept Walker
{
	/*
		Walker is the only object which actually knows the nature of the problem.
		It is responsible for:
			- maintaining the current solution
			- preparing the proposition of the new step
			- making the proposed step

		It has to contain an initial solution before calling search().
		Better solutions have lower fitness.

		Input:
			progress \in [0,1)
			Random
		Output:
			best_fitness
			current_fitness
			next_fitness
	*/

	template<typename Random> void prepare_step(double progress, Random &random);
	/* 
		Prepares a proposition of a single step (it doesn't change the current solution).
		Let next solution be the solution after making step from the current solution.
		Fitness of the next solution should be returned by next_fitness().
		search() provides that prepare_step() will be called in each iteration exactly once.
	*/

	void make_step();
	/*
		Performs the step prepared by the last execution of prepare_step(),
		i.e. the current solution shall change to the next solution.
	*/
	
	double best_fitness();
	/*
		Returns fitness of the best solution found so far.
		It can change only during the execution of prepare_step().
	*/

	double current_fitness();
	/*
		Returns fitness of the current solution.
		It changes only during execution of make_step().
	*/

	double next_fitness();
	/*
		Returns fitness of the next solution (see prepare_step()).
		Before the first call of prepare_step(), behaviour of next_fitness() is undefined.
	*/

};

concept StepCtrl
{
	/*
		StepCtrl (Step Controller) represents the metaheuristic chosen to solve the problem.
		It is responsible for making decision whether to make the step proposed by Walker.
		
		Input:
			delta_fitness = next_fitness - current_fitness
			progress \in [0,1)
			Random
		Output:
			step_decision
	*/

	template<typename Random> bool step_decision(double delta_fitness, double progress, Random &random);
	{ Why not (current_fitness, next_fitness)? }
	/*
		Returns true iff step proposed by the Walker should be made.
		
		examples:	
			In annealing, the decision would be made according to the delta_fitness and the temperature schedule.
			In hill climb, the decision would be solely based on delta_fitness.
			{ What should be done for tabu search? Do we really care? }
	*/

};

concept ProgressCtrl
{
	/*
		ProgressCtrl (Progress Controller) controls the execution time of the local search.
		It is responsible for estimation of the ratio: iterations passed/iterations available.

		Input:
			best_fitness
		Output:
			progress \in [0;inf)
	*/

	double progress(double best_fitness); { Why not current_fitness? }
	/*
		Returns non-negative value estimating the ratio described above.
		search() provides that progress() will be called exatly once before every iteration.
		Returning value >=1 will cause search() to exit without performing the next iteration.

		examples:
			[iteration limit] (iterations passed)/(predetermined number of iterations available)
			[time limit] (time passed)/(predetermined time available)
			[sufficiency treshold] (acceptable fitness)/best_fitness
			[convergence treshold] max(0,1+\epsilon-c*((best fitness x iterations ago)-best_fitness))
	*/
};

concept Random [c++11 RNG concept];
/*
	Generates random integer values.
	It is explicitly shared between components of the search() for the following reasons:
	- we assume that we receive only one seed from the outside
	- using many generators at once (especially with the same seed) may create undesired conditional probabilities
*/

concept Logger
{
	/*
		It logs fitness over algorithm execution time/iterations.
		{ To what extent does it overlap with the ProgressCtrl? Should it take progress argument? }

		Input:
			current_fitness
	*/

	void log(double current_fitness); { Why not best_fitness? }
	/*
		It logs current fitness.
		search() provides that log() will be called exactly once before every iteration once after the last one.
	*/
};


=====================================
3. FEATURES FOR IMPLEMENTING A WALKER
=====================================

We have observed that sometimes it is possible to enhance the local search
by making the neighbourhood size (from which we choose the step) progress dependent.
In the euclidian TSP example, assuming that our step consists of reversing a segment of the cycle,
it occurs to be profitable to decrease the expected length of that segment along the time
(intuitively it is equivalent to untying smaller and smaller "knots" in our solution).
We suspect that it can be generalized, therefore a StepSize concept has been introduced.
We are going to implement a few potentially useful variants of StepSize,
although the concept itself is not a part of the local search framework.

concept StepSize
{
	/*
		Hints a length of the step (neighbourhood ball radius) to generate.

		Input:
			Random
			progress \in [0;1)
		Output:
			step_size
	*/

	uint32_t hint(double progress, Random &random); { Why uint32_t? }
	/*
		Returns the length of the step generated according to some progress dependent distribution.

		examples:
			TODO
	*/
};

