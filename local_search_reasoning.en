Date: 11.01.2013

Local Search Framework is supposed to automatize the process of writing local searches with no execution overhead due to the framework code.
Framework should be responsible for making consistent decisions about the issues that are not influencing the algorithm itself
(for example results logging, repetitive testing, limiting execution time) and allow to avoid rewriting repetitive code.
As the concept of local searches is really simple, our design has to be easily comprehensible and super intuitive.
It definitely shouldn't force user to bend/hack the solution to fit the framework.

framework levels:
[still in design] SuperLogger - responsible for providing logger and harvest statistics across multiple algorithms and their runs.
search()
[planned] Walker utils - components provided to the user which he may use while implementing the Walker.
[nothing done] problem specific Walkers

We use templates and concepts to avoid any overhead in the execution time and allow maximum flexibility.

Outer interface of the framework consists of a single template function search().
Its code is explicitly stated in the design - user HAS TO KNOW this piece of code before using the framework.
The order of actions performed is vital for utilization of the framework.
Therefore search() has to be simple and readable for an average user.

fitness - we assumed that fitness of the solution can be efficiently calculated and represented as a floating point number.
We believe that imposing the fitness type across the framework is a useful simplification and prevents any type conversion problems in this context.
In the current version fitness type is set to double which is disputable but convenient.

On the top level of the framework, ie. search() and concepts it uses we don't know the nature of the problem.
It is due to the fact that we wanted to extract problem independent components.

[concept] Walker - only component which knows the nature of the problem.
It is not divided on this framework level, since if more components would know about the problem it would create cross dependencies.
In other words, such situation would inevitably make search() to transfer problem specific data between them.
Also many custom/intrusive optimization can be made at this point, so we believe that this is definitely a point at which we should allow user to plug in
his own code.

[concept] PRNG has to be shared, since only 1 seed is expected to be provided and using multiple PRNGs can cause conditional probabilities

[concept] ProgressCtrl (progress controller) - is usually implemented as a time/iteration limit or sufficiency treshold.
None of these are problem dependent, hence this component can be effectively extracted from the design.

[concept] StepCtrl (step controller) - component deciding whether to perform a step - represents the metaheuristic used.
annealing and hill climb have easy/trivial implementations for this concept.
No idea how to apply tabu search here though, since it is problem specific (since we had no practical applications of tabu planned, this question remains open).

[concept] Logger - it is supposed to effectively harvest the relevant information about the performance basing on the fitness (assumed to be ultimate measure).




