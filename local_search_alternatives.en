Reasoning of local search framework design and alternative approaches
=====================================================================

We have considered approaches alternative to proposed design, they are worth
studying in order to identify possible problems and why current design solves
them (in our opinion).

Naming conventions and general rules
------------------------------------

In local search design paper we have identified small number of concepts,
atomic building blocks of local search algorithm in our framework. We also
decided to use C++ templates system to implement different specimens of the
same concept, therefore if one concept uses the other one (e.g. calls, reads
data, owns) it has to know a its type (or in some cases just implicit
interface).

Representation of local search framework
----------------------------------------

It is helpful to express structure of local search framework in terms of a
graph where each node represents a separated concept and an edge A -> B exists
iff concept A uses (e.g. calls, owns, reads data) concept B. First assumption
was that resulting graph is compact, local search algorithm provided by the
framework should be seen as one phase from the outside (e.g. invocation of one
function, which takes input and returns result), so every concept in different
connected component than local search algorithm itself is useless.

The way to the (spanning) tree
------------------------------

We have eliminated all designs with cycles in 'concepts graph', the most
important reason for this was that we couldn't find how we can benefit from
allowing two way communication between components. Furthermore all concepts
need to be initialized (either by user or search procedure itself if they are
completely algorithm independent like statistics gathering) and every cycle
makes initialization really complicated, there is no arbitrary choice of
initialization order we could come up with in this case.

Therefore we were free to choose either general DAG or a tree (we were aiming
for the latter). To reduce both cases to one (actually they already are) we can
run depth-first search from our local search algorithm's 'entry point'
(search() function), which becomes root of a depth-first spanning tree. The
only difference between 'concepts graph' being a general DAG and a tree is
manifested by the presence of non-tree edges. Our graph is acyclic, so we
won't find back edges.

Please note that presence of back edges would mean that execution flow can be
returned to caller for a moment and then returned back to the callee
automatically - this can obviously be replaced by making communication
'passive', caller provides all data needed do execute call (query) and expects
response, every query is initiated by caller and completed by callee using
provided data.

Forward edges elimination
-------------------------

Any forward edge means that we are skipping many (abstraction) layers with an
invocation. Obviously this can be avoided by passing a call through all layers
that are bypassed by a forward edge. We replace forward edge with composition
of facades. Modern C++ compilers can easily inline such constructions, so that
the forward edge won't be present in design (and C++ code), but will be
generated by compiler for performance reasons.

Moreover every forward edge means that at least two different concepts need to
know (the same) type of called concept, we think it is less convenient during
initialization, however in this specific case one concept can inherit type from
the one residing closer to root in spanning tree (as long as the former is not
initialized by a user).

We have made an experiment with changing parts of an algorithm (namely
underlying data structure) during algorithm execution. Obviously allowing
forward edge in this case (calling specific data structure directly, skipping
its owner) might invalidate algorithm. The real problem here is obviously
stupid user who gave an ownership to the object being descendant of a caller
while allowing forward edges in 'concepts graph'. Removing forward edge as
described above forces every call to pass through data structure owner, it is
less error-prone and simpler.

We further assume that there is no forward edges in 'concepts graph'.

Cross edges discussion
----------------------

Consider the case where one concept C is a child of two (or more) concepts A
and B (assume B -> C is a cross edge). Let P be the lowest common ancestor of
both A and B in depth-first spanning tree of 'concepts graph'. Described
situation breaks composability of algorithm design but one can easily come up
with example of a local search algorithm where such design is desired, we will
discuss it later, for now let us assume that we do need communication between
components as described above.

If we disallow cross edges in our local search design we have to provide
different mechanism of communication between B and C. As 'concepts graph'
without cross edges is a tree we have to pass data back (query result) from C
to P and provide B with it in separate call. The obvious problem here is that
data format must be know to all concepts on paths from B and C do P (including
P) and data format type can (in most cases will) be domain dependant -
therefore we are raising domain boundary up to lowest common ancestor of
components that were connected by cross edge. This means that protocol common
to B and C (which may change) must be propagated during initialization down in
the tree starting from P.

The obvious benefits from tree-like 'concepts graph' is simple, to-down
initialization, we can assume that during construction of algorithm child being
initialized is given an interface (e.g. a reference) to obtain initialization
data from parent (depending on its needs) or this data is passed explicitly.
Furthermore there is no problem with assigning an ownership of a concept.  Tree
design makes synchronization model extremely easy to implement (not necessarily
efficient) in case one would like concepts to operate concurrently.

TODO

There are several problems with cross edges. Initialization cannot be done
top-down (in described automatic fashion), ownership assignment (as entire
initialization) needs to be done by user as hidden dependencies are not obvious
to any automatic model (unless explicitly stated e.g. in a form of graph which
is a total overkill). It is pretty obvious that the less constraints we put on
algorithms design the less we know and can do automatically.

TODO

Other desired traits of design
------------------------------

As already said we would like to limit number of concepts dependent on domain
or possibly hide this dependency in an optional concept.

TODO
