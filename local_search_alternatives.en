Reasoning of local search framework design and alternative approaches
=====================================================================

We have considered approaches alternative to proposed design, they are worth
studying in order to identify possible problems and why current design solves
them (in our opinion).

Naming conventions and general rules
------------------------------------

In local search design paper we have identified small number of concepts,
atomic building blocks of local search algorithm in our framework. We also
decided to use C++ templates system to implement different specimens of the
same concept, therefore if one concept uses the other one (e.g. calls, reads
data, owns) it has to know a its type (or in some cases just implicit
interface).

Representation of local search framework
----------------------------------------

It is helpful to express structure of local search framework in terms of a
graph where each node represents a separated concept and an edge A -> B exists
iff concept A uses (e.g. calls, owns, reads data) concept B. First assumption
was that resulting graph is compact, local search algorithm provided by the
framework should be seen as one phase from the outside (e.g. invocation of one
function, which takes input and returns result), so every concept in different
connected component than local search algorithm itself is useless.

The way to the (spanning) tree
------------------------------

We have eliminated all designs with cycles in 'concepts graph'.
TODO why no cycle?

Therefore we were free to choose either general DAG or a tree (we were aiming
for the latter). To reduce both cases to one (actually they already are) we
can run depth-first search from our local search algorithm's 'entry point'
(search() function), which becomes root of a depth-first spanning tree. The
only difference between 'concepts graph' being a general DAG and a tree is
manifested by the presence of non-tree edges. Our graph is acyclic, so we won't
find back edges.

We addressed next section to the problem of cross edges.

Forward edges elimination
-------------------------

Any forward edge means that we are skipping many (abstraction) layers with an
invocation. Obviously this can be avoided by passing a call through all layers
that are bypassed by a forward edge. We replace forward edge with composition
of facades. Modern C++ compilers can easily inline such constructions, so that
the forward edge won't be present in design (and C++ code), but will be
generated by compiler for performance reasons.

Moreover every forward edge means that at least two different concepts need to
know (the same) type of called concept, we think it is less convenient during
initialization, however in this specific case one concept can inherit type from
the one residing closer to root in spanning tree (as long as the former is not
initialized by a user).

We have made an experiment with changing parts of an algorithm (namely
underlying data structure) during algorithm execution. Obviously allowing
forward edge in this case (calling specific data structure directly, skipping
its owner) might invalidate algorithm. The real problem here is obviously
stupid user who gave an ownership to the object being descendant of a caller
while allowing forward edges in 'concepts graph'. Removing forward edge as
described above forces every call to pass through data structure owner.

We further assume that there is no forward edges in 'concepts graph'.

Cross edges discussion
----------------------



Drawbacks of existing design
----------------------------



% TODO

% general: reduce height of tree, branch factor is not a problem, all
% initialization should be independent (otherwise has to be done in external
% preparer (unnecessary separation) or search() (unacceptable))

% cross references: ownership problem, type system, template arguments, hidden
% dependencies, lean look-and-feel wasted by initialization, parts of
% initialization moved to search function (binding domain specific concepts if
% needed), fixed synchronization points, no black box approach, protocols
% between concepts visible to upper layer, hard updates

% general: cheap splitting possible only when protocols are fixed and domain
% independent (type system)

% tree design: commons go to lowest common ancestor in tree, everything becomes
% domain dependent (raising the barrier)

% idea: tabu should be implemented on the level of generating next element to
% lookup, therefore we're not generating and filtering out (and making step
% controller unnecessary)
